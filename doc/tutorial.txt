-----------------------------------------------------------------------
Pre Make Kit tutorial file

Document revision:
$Id$
-----------------------------------------------------------------------


			    PMK tutorial



1) Introduction
   ------------

As make is using a makefile, the pmk binary is using a pmkfile. This
file contains a set of commands that perform checks of source
dependencies. Following to that, template files are processed to
generate a final file after tags substitutions. Additionaly to this
tutorial, we highly recommend to consult pmkfile(5).



2) The settings
   ------------

The first command you will find in a pmkfile is named SETTINGS. Its
function is to define global settings. To begin we are going to use
only one template for the makefile. See the following example:

SETTINGS {
	TARGET = ("Makefile.in")
}

The TARGET option is taking a list as value. The list is delimited by
parenthesis. As you can see Makefile.in will be the template name.



3) Defining some variables
   -----------------------

It can be useful to define some basic variables such as package name
and version. For this, we will use the DEFINE command as following:

DEFINE {
	PACKAGE = "hello"
	VERSION = "0.1"
}

If the target(s) file(s) contain(s) the @PACKAGE@ and @VERSION@ tags then
they will be replaced by the variables values.


4) First check
   -----------

Lets say that we have a hello.c file that needs the string header.
For that, we use the CHECK_HEADER command like following:

CHECK_HEADER(header_string) {
	NAME = "string.h"
}

The NAME option contains the header to check. The string into brackets
is the label of the command. If the check succeed this label is set as
true else it is set as false. We'll see later how to use this label
state into conditional command or as dependency with the DEPEND option.

Now let's see what our actual pmkfile contains. First we create the
template with the following commands:

echo "PACKAGE=@PACKAGE@" > Makefile.in
echo "VERSION=@VERSION@" >> Makefile.in

You can now type 'pmk'. The resulting output should look like this:

__[OUTPUT]____________________________________________________[BEGIN]__

Processing commands :

* Parsing settings
        Collecting targets :
                Added 'Makefile.in'.
                Total 1 target(s) added.

* Parsing define
        defined 'PACKAGE' variable.
        defined 'VERSION' variable.

* Checking header [header_string]
        Use C language with CC compiler.
        Store compiler flags in 'CFLAGS'.
        Found header 'string.h' : yes.

Process templates :
Created '/home/mips/tmp/Makefile'.

__[OUTPUT]______________________________________________________[END]__

And the generated Makefile should look like:

__[FILE]______________________________________________________[BEGIN]__
PACKAGE=hello
VERSION=0.1
__[FILE]________________________________________________________[END]__



5) Using external libraries
   ------------------------

Our hello program also needs the curses library. To check if this
library is present we will use the following command:

CHECK_LIB(lib_curses) {
	NAME = "curses"
}

Which gives as result:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking library [lib_curses]
        Use C language with CC compiler.
        Store library flags in 'LIBS'.
        Found library 'curses' : yes.

__[OUTPUT]______________________________________________________[END]__

We could also check for a specific function in the library:

CHECK_LIB(lib_curses) {
	NAME = "curses"
	FUNCTION = "getwin"
}

So you'll get the following:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking library [lib_curses]
        Use C language with CC compiler.
        Store library flags in 'LIBS'.
        Found function 'getwin' in 'curses' : yes.

__[OUTPUT]______________________________________________________[END]__

The linker flags are automatically set in the default LIBS variable.
We'll see later how to use an alternate variable.



6) Playing with pkg-config support
   -------------------------------

Let's say that our package has the gtkhello.c source that builds a gtk
version of our hello program. That said, we need to check if gtk is present
on the system. We have two possibilities to do that: first by using
pkg-config or the second one by checking the library.

We are going to learn how to check gtk via pkgconfig support:

CHECK_PKG_CONFIG(pc_gtk) {
	NAME = "gtk+"
}

If gtk is present you should get the following output when running pmk:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking pkg-config module [pc_gtk]
        Found package 'gtk+' : yes.
        Stored compiler flags in 'CFLAGS'.
        Stored library flags in 'LIBS'.

__[OUTPUT]______________________________________________________[END]__

We could also check for a minimal version of gtk needed by the program.
For example we could look for at least 1.2 version of gtk:

CHECK_PKG_CONFIG(pc_gtk) {
	NAME = "gtk+"
	VERSION = "1.2"
}

And the related output:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking pkg-config module [pc_gtk]
        Found package 'gtk+' : yes.
        Found version >= 1.2 : yes (1.2.10).
        Stored compiler flags in 'CFLAGS'.
        Stored library flags in 'LIBS'.

__[OUTPUT]______________________________________________________[END]__

As you can see the compiler and linker flags are automatically stored
in the default CFLAGS and LIBS variables. You can provide alternate
variables with the CFLAGS and LIBS options like following:

CHECK_PKG_CONFIG(pc_gtk) {
	NAME = "gtk+"
	VERSION = "1.2"
	CFLAGS = "GTK_CFLAGS"
	LIBS = "GTK_LIBS"

}

And you'll get:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking pkg-config module [pc_gtk]
        Found package 'gtk+' : yes.
        Found version >= 1.2 : yes (1.2.10).
        Stored compiler flags in 'GTK_CFLAGS'.
        Stored library flags in 'GTK_LIBS'.

__[OUTPUT]______________________________________________________[END]__

Notice that the storage variables have changed in the output.


7) Checking types
   --------------

As an example we will check for the ISO C99 boolean type: _Bool. See
the following:

CHECK_TYPE(type_bool_isoc) {
	NAME = "_Bool"
}

As my compiler is not fully ISO C99 compliant i get an error:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking type [type_bool_isoc]
        Use C language with CC compiler.
        Found type '_Bool' : no.
Error : failed to find type '_Bool'.
__[OUTPUT]______________________________________________________[END]__

This test could be useful to detect compilers that are ISO C99
compliant. For those which are not we could include an external
definition of this type. That said, pmk is exiting with an error by
default if a check fails. To avoid this we'll use the REQUIRED option:

CHECK_TYPE(type_bool_isoc) {
	REQUIRED = FALSE
	NAME = "_Bool"
}

And it gives the following:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking type [type_bool_isoc]
        Use C language with CC compiler.
        Found type '_Bool' : no.

__[OUTPUT]______________________________________________________[END]__

Now let's see how to use this test. First we must create an header that
will contains the tags. Here is isoc_compat.h.in:

__[FILE]______________________________________________________[BEGIN]__
/* ISO C compatibility header */


/* _Bool type */
@DEF___BOOL@

__[FILE]________________________________________________________[END]__

Now add this file in the target list:

SETTINGS {
	TARGET = ("Makefile.in","isoc_compat.h.in")
}

The definition tag is easy to build, it's "DEF__" followed by the
string of the type in uppercase: _Bool gives _BOOL.

Now see the result:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking type [type_bool_isoc]
        Use C language with CC compiler.
        Found type '_Bool' : no.

Process templates :
Created '/home/mips/tmp/pmk_tutor/Makefile'.
Created '/home/mips/tmp/pmk_tutor/isoc_compat.h'.

End of log
__[OUTPUT]______________________________________________________[END]__

And the isoc_compat.h file:

__[FILE]______________________________________________________[BEGIN]__
/* ISO C compatibility header */


/* _Bool type */
#undef HAVE__BOOL

__[FILE]________________________________________________________[END]__

The @DEF___BOOL@ has been replaced by "#undef HAVE__BOOL". Now we can
add the code to include the definition of _Bool type if it does not
exist.

__[FILE]______________________________________________________[BEGIN]__
/* ISO C compatibility header */


/* _Bool type */
@DEF___BOOL@

#ifndef HAVE__BOOL
typedef unsigned char _Bool;
#endif

__[FILE]________________________________________________________[END]__


Which results in the following on my system:

__[FILE]______________________________________________________[BEGIN]__
/* ISO C compatibility header */


/* _Bool type */
#undef HAVE__BOOL

#ifndef HAVE__BOOL
typedef unsigned char _Bool;
#endif

__[FILE]________________________________________________________[END]__

Mission succeeded !


8) Looking for a binary ?
   ----------------------

Easy ! Need to know if strip program is available ? Use the following:

CHECK_BINARY(bin_strip) {
	NAME = "strip"
	VARIABLE = "STRIP_PATH"
}

and add the tag in the Makefile.in template:

__[FILE]______________________________________________________[BEGIN]__
PACKAGE=@PACKAGE@
VERSION=@VERSION@
STRIP_PATH=@STRIP_PATH@
__[FILE]________________________________________________________[END]__


Now run pmk:

__[OUTPUT]____________________________________________________[BEGIN]__

* Checking binary [bin_strip]
        Found binary 'strip' : yes.

__[OUTPUT]______________________________________________________[END]__

And lookt at Makefile:

__[FILE]______________________________________________________[BEGIN]__
PACKAGE=hello
VERSION=0.1
STRIP_PATH=/usr/bin/strip
__[FILE]________________________________________________________[END]__

Well we got it :)



TO BE CONTINUED ...
