/* $Id$ */

/*
 * Copyright (c) 2003-2005 Damien Couderc
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *    - Neither the name of the copyright holder(s) nor the names of its
 *      contributors may be used to endorse or promote products derived
 *      from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef _PMKSCAN_H_
#define _PMKSCAN_H_

#include <stdio.h>
#include "dynarray.h"
#include "hash.h"
#include "parse_lang.h"

/**********
 constants
************************************************************************/

/* pmkscan specific version */
#define PREMAKE_SUBVER_PMKSCAN	"5"

#ifndef DATADIR
/* for lint */
#define DATADIR	"/DATADIR_not_defined"
#endif

#define PMKSCAN_DATA	DATADIR "/pmkscan.dat"
#define PMKSCAN_PMKFILE	"pmkfile.scan"
#define PMKSCAN_MKFILE	"Makefile.scan"

/* languages, should use lgdata later */
#define PMKSCAN_LANG_C          "C"
#define PMKSCAN_LANG_CXX        "C++"

#define PSC_MAIN_C		"main"

#define PSC_TOK_INCL	1
#define PSC_TOK_FUNC	2

/* source file type */
#define SRC_TYPE_UNKNOWN	0
#define SRC_TYPE_ASM		1
#define SRC_TYPE_C			2
#define SRC_TYPE_CXX		3
#define SRC_TYPE_LEX		4
#define SRC_TYPE_YACC		5

/* object type */
#define OBJ_TYPE_UNKNOWN	0
#define OBJ_TYPE_ASM		1
#define OBJ_TYPE_C			2
#define OBJ_TYPE_CXX		3

#define OBJ_SUFFIX		".o"

#define MKF_OUTPUT_WIDTH	72
#define MKF_TAB_WIDTH		4

#define MKF_TIME_GEN	"%F"
#define MKF_HEADER_GEN	"# Makefile template generated by pmkscan (%s).\n\n"

#define MKF_HEADER_ASM	"AS=\t\t\t@AS@\n" \
						"ASFLAGS=\n"
#define MKF_HEADER_C	"CC=\t\t\t@CC@\n" \
						"CFLAGS=\t\t@CFLAGS@\n"
#define MKF_HEADER_CXX	"CXX=\t\t\t@CXX@\n" \
						"CXXFLAGS=\t\t@CXXFLAGS@\n"

#define MKF_HEADER_YACC	"YACC=\t\t@YACC@\n" \
						"YFLAGS=\t@YFLAGS@\n"

#define MKF_HEADER_LEX	"LEX=\t\t@LEX@\n" \
						"LFLAGS=\t@LFLAGS@\n"

#define MKF_HEADER_LD	"LD=\t\t\t@LD@\n" \
						"# LDFLAGS shall contain -lc if used with ld\n" \
						"LDFLAGS=\t@LDFLAGS@\n"
#define MKF_HEADER_MISC	"RM=\t\t\trm\n" \
						"RMFLAGS=\t-rf\n"

#define MKF_LINE_JUMP	"\n"
#define MKF_TWICE_JUMP	"\n\n"

#define MKF_SUFFIXES	"\n.SUFFIXES: .o .s .c\n"

#define MKF_BLD_ASM_OBJ		"\n# assembly suffixes\n" \
							".s.o:\n" \
							"\t$(AS) $(ASFLAGS) -c $<\n"
#define MKF_BLD_C_OBJ		"\n# C suffixes\n" \
							".c.o:\n" \
							"\t$(CC) $(CFLAGS) -c $<\n" \
							"\n.C.o:\n" \
							"\t$(CC) $(CFLAGS) -c $<\n" \
							"\n.cc.o:\n" \
							"\t$(CC) $(CFLAGS) -c $<\n"
#define MKF_BLD_CXX_OBJ		"\n# C++ suffixes\n" \
							".cxx.o:\n" \
							"\t$(CXX) $(CXXFLAGS) -c $<\n" \
							"\n.cpp.o:\n" \
							"\t$(CXX) $(CXXFLAGS) -c $<\n" \

#define MKF_BLD_YACC_SRC	"\n# yacc suffixes\n" \
							".y.c:\n" \
							"\t$(YACC) $(YFLAGS) $<\n" \
							"\tmv y.tab.c $@\n"

#define MKF_BLD_LEX_SRC		"\n# lex suffixes\n" \
							".l.c:\n" \
							"\t$(LEX) $(LFLAGS) $<\n" \
							"\tmv lex.yy.c $@\n"

#define MKF_OBJECT_SRCS	"%s_SRCS=\t"
#define MKF_OBJECT_LABL	"%s: $(%s_SRCS)\n"

#define MKF_TARGET_OBJS	"%s_OBJS=\t"
#define MKF_TARGET_LABL	"%s: $(%s_OBJS)\n" \
						"\t$(LD) $(LDFLAGS) -o %s $(%s_OBJS)\n\n" /* XXX specific ??!! */
#define MKF_TARGET_CLN	"%s_clean:\n" \
						"\t$(RM) $(RMFLAGS) $(%s_OBJS)\n" \
						"\t$(RM) $(RMFLAGS) %s\n\n"

#define MKF_TRGT_ALL_VAR	"ALL_TARGETS=\t"
#define MKF_TRGT_CLEAN_VAR	"ALL_CLEAN_TARGETS=\t"
#define MKF_TARGET_ALL		"all: $(ALL_TARGETS)\n\n"
#define MKF_TARGET_CLEAN	"clean: $(ALL_CLEAN_TARGETS)\n\n"
#define MKF_TARGET_INST		"install:\n" \
							"\t# put your install stuff here\n\n" \
							"deinstall:\n" \
							"\t# put your deinstall stuff here\n\n"


/*******************************
 type and structure definitions
************************************************************************/

/* pseudo token type */
typedef unsigned char	ttype_t;

/* file type and extension struct */
typedef unsigned char	ftype_t;
typedef struct {
	char	*ext;
	ftype_t	 type;
} scn_ext_t;

/* node structure */
typedef struct {
	char		*fname,			/* filename */
				*obj_name,		/* object name */
				*prefix;		/* prefix name */
	bool		 isdep,			/* is a dependency flag ? */
				 mainproc;		/* has main() proc flag ? */
	dynary		*system_inc,	/* system include list */
				*local_inc,		/* local include list */
				*func_calls,	/* function call list */
				*func_decls,	/* function declaration list */
				*type_idtfs,	/* type identifier list */
				*src_deps,		/* source dependency list */
				*obj_links,		/* object link dependencies */
				*obj_deps;		/* type dependency list */
	ftype_t		 type;			/* file type */
	int			 score;			/* hit score */
} scn_node_t;

/* global scanning data */
typedef struct {
	bool	 found_asm,		/* whether at least one file is assembly */
			 found_c,		/* whether at least one file is C */
			 found_cxx,		/* whether at least one file is C++ */
			 found_lex,		/* whether at least one file is lex */
			 found_yacc;	/* whether at least one file is yacc */
	htable	*nodes,
			*objects,
			*targets,
			*checks;
} scn_glob_t;

/* misc scanning stuff */
typedef struct {
	bool		*is_asm,
				*is_c,
				*is_cxx,
				*is_lex,
				*is_yacc;
	prs_cmn_t	*pcmn;
	scn_node_t	*pnode;
	htable		*nodes;
} scn_misc;

/* scanning data parsed from dat file */
typedef struct {
	htable	*functions,
			*includes;
} scandata;


/*********************
 functions prototypes
************************************************************************/

/* init functions */
scn_node_t	*scan_node_init(char *);
void		 scan_node_destroy(scn_node_t *);
scn_glob_t	*scan_glob_init(void);
void		 scan_glob_destroy(scn_glob_t *);

/* pmkfile specific */
bool		 parse_data_file(prsdata *, scandata *);
bool		 idtf_check(char *, htable *, htable *, htable *);
bool		 gen_checks(scn_glob_t *, scandata *);
bool		 scan_build_pmk(char *fname, scn_glob_t *, scandata *);

/* makefile specific */
bool		 find_deps(dynary *, dynary *);
bool		 da_find(dynary *, char *);
void		 extract_dir(char *, char *, size_t);
void		 build_path(char *, char *, char *, size_t);
bool		 recurse_obj_deps(htable *, dynary *, char *);
bool		 gen_objects(scn_glob_t *);
bool		 recurse_src_deps(scn_glob_t *, dynary *, char *);
bool		 gen_targets(scn_glob_t *);
size_t		 fprintf_width(size_t, size_t, size_t, FILE *, char *);
bool		 scan_build_mkf(char *, scn_glob_t *);

/* common functions */
void		 str_to_upper(char *, size_t, char *);
ftype_t		 check_file_ext(char *);
char		*regex_check(char *, char *);
bool		 process_ppro(void *, char *, prseng_t *);
bool		 process_proc_call(void *, char *, prseng_t *);
bool		 process_proc_decl(void *, char *, prseng_t *);
bool		 process_type(void *, char *, prseng_t *);
bool		 parse_file(prs_cmn_t *, scn_node_t *, char *, ftype_t);
bool		 scan_node_file(prs_cmn_t *, char *, bool);
bool		 scan_dir(prs_cmn_t *, char *, bool);
void		 usage(void);

#endif /* _PMKSCAN_H_ */
